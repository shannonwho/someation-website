{"ast":null,"code":"import _slicedToArray from \"/Users/shannonhu/Documents/Somestage/someation-website/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport * as React from 'react';\nvar LEFT = \"Left\";\nvar RIGHT = \"Right\";\nvar UP = \"Up\";\nvar DOWN = \"Down\";\n\n/* global document */\nvar defaultProps = {\n  delta: 10,\n  preventScrollOnSwipe: false,\n  rotationAngle: 0,\n  trackMouse: false,\n  trackTouch: true,\n  swipeDuration: Infinity,\n  touchEventOptions: {\n    passive: true\n  }\n};\nvar initialState = {\n  first: true,\n  initial: [0, 0],\n  start: 0,\n  swiping: false,\n  xy: [0, 0]\n};\nvar mouseMove = \"mousemove\";\nvar mouseUp = \"mouseup\";\nvar touchEnd = \"touchend\";\nvar touchMove = \"touchmove\";\nvar touchStart = \"touchstart\";\nfunction getDirection(absX, absY, deltaX, deltaY) {\n  if (absX > absY) {\n    if (deltaX > 0) {\n      return RIGHT;\n    }\n    return LEFT;\n  } else if (deltaY > 0) {\n    return DOWN;\n  }\n  return UP;\n}\nfunction rotateXYByAngle(pos, angle) {\n  if (angle === 0) return pos;\n  var angleInRadians = Math.PI / 180 * angle;\n  var x = pos[0] * Math.cos(angleInRadians) + pos[1] * Math.sin(angleInRadians);\n  var y = pos[1] * Math.cos(angleInRadians) - pos[0] * Math.sin(angleInRadians);\n  return [x, y];\n}\nfunction getHandlers(set, handlerProps) {\n  var onStart = function onStart(event) {\n    var isTouch = (\"touches\" in event);\n    // if more than a single touch don't track, for now...\n    if (isTouch && event.touches.length > 1) return;\n    set(function (state, props) {\n      // setup mouse listeners on document to track swipe since swipe can leave container\n      if (props.trackMouse && !isTouch) {\n        document.addEventListener(mouseMove, onMove);\n        document.addEventListener(mouseUp, onUp);\n      }\n      var _ref = isTouch ? event.touches[0] : event,\n        clientX = _ref.clientX,\n        clientY = _ref.clientY;\n      var xy = rotateXYByAngle([clientX, clientY], props.rotationAngle);\n      props.onTouchStartOrOnMouseDown && props.onTouchStartOrOnMouseDown({\n        event: event\n      });\n      return Object.assign(Object.assign(Object.assign({}, state), initialState), {\n        initial: xy.slice(),\n        xy: xy,\n        start: event.timeStamp || 0\n      });\n    });\n  };\n  var onMove = function onMove(event) {\n    set(function (state, props) {\n      var isTouch = (\"touches\" in event);\n      // Discount a swipe if additional touches are present after\n      // a swipe has started.\n      if (isTouch && event.touches.length > 1) {\n        return state;\n      }\n      // if swipe has exceeded duration stop tracking\n      if (event.timeStamp - state.start > props.swipeDuration) {\n        return state.swiping ? Object.assign(Object.assign({}, state), {\n          swiping: false\n        }) : state;\n      }\n      var _ref2 = isTouch ? event.touches[0] : event,\n        clientX = _ref2.clientX,\n        clientY = _ref2.clientY;\n      var _rotateXYByAngle = rotateXYByAngle([clientX, clientY], props.rotationAngle),\n        _rotateXYByAngle2 = _slicedToArray(_rotateXYByAngle, 2),\n        x = _rotateXYByAngle2[0],\n        y = _rotateXYByAngle2[1];\n      var deltaX = x - state.xy[0];\n      var deltaY = y - state.xy[1];\n      var absX = Math.abs(deltaX);\n      var absY = Math.abs(deltaY);\n      var time = (event.timeStamp || 0) - state.start;\n      var velocity = Math.sqrt(absX * absX + absY * absY) / (time || 1);\n      var vxvy = [deltaX / (time || 1), deltaY / (time || 1)];\n      var dir = getDirection(absX, absY, deltaX, deltaY);\n      // if swipe is under delta and we have not started to track a swipe: skip update\n      var delta = typeof props.delta === \"number\" ? props.delta : props.delta[dir.toLowerCase()] || defaultProps.delta;\n      if (absX < delta && absY < delta && !state.swiping) return state;\n      var eventData = {\n        absX: absX,\n        absY: absY,\n        deltaX: deltaX,\n        deltaY: deltaY,\n        dir: dir,\n        event: event,\n        first: state.first,\n        initial: state.initial,\n        velocity: velocity,\n        vxvy: vxvy\n      };\n      // call onSwipeStart if present and is first swipe event\n      eventData.first && props.onSwipeStart && props.onSwipeStart(eventData);\n      // call onSwiping if present\n      props.onSwiping && props.onSwiping(eventData);\n      // track if a swipe is cancelable (handler for swiping or swiped(dir) exists)\n      // so we can call preventDefault if needed\n      var cancelablePageSwipe = false;\n      if (props.onSwiping || props.onSwiped || props[\"onSwiped\".concat(dir)]) {\n        cancelablePageSwipe = true;\n      }\n      if (cancelablePageSwipe && props.preventScrollOnSwipe && props.trackTouch && event.cancelable) {\n        event.preventDefault();\n      }\n      return Object.assign(Object.assign({}, state), {\n        // first is now always false\n        first: false,\n        eventData: eventData,\n        swiping: true\n      });\n    });\n  };\n  var onEnd = function onEnd(event) {\n    set(function (state, props) {\n      var eventData;\n      if (state.swiping && state.eventData) {\n        // if swipe is less than duration fire swiped callbacks\n        if (event.timeStamp - state.start < props.swipeDuration) {\n          eventData = Object.assign(Object.assign({}, state.eventData), {\n            event: event\n          });\n          props.onSwiped && props.onSwiped(eventData);\n          var onSwipedDir = props[\"onSwiped\".concat(eventData.dir)];\n          onSwipedDir && onSwipedDir(eventData);\n        }\n      } else {\n        props.onTap && props.onTap({\n          event: event\n        });\n      }\n      props.onTouchEndOrOnMouseUp && props.onTouchEndOrOnMouseUp({\n        event: event\n      });\n      return Object.assign(Object.assign(Object.assign({}, state), initialState), {\n        eventData: eventData\n      });\n    });\n  };\n  var cleanUpMouse = function cleanUpMouse() {\n    // safe to just call removeEventListener\n    document.removeEventListener(mouseMove, onMove);\n    document.removeEventListener(mouseUp, onUp);\n  };\n  var onUp = function onUp(e) {\n    cleanUpMouse();\n    onEnd(e);\n  };\n  /**\n   * The value of passive on touchMove depends on `preventScrollOnSwipe`:\n   * - true => { passive: false }\n   * - false => { passive: true } // Default\n   *\n   * NOTE: When preventScrollOnSwipe is true, we attempt to call preventDefault to prevent scroll.\n   *\n   * props.touchEventOptions can also be set for all touch event listeners,\n   * but for `touchmove` specifically when `preventScrollOnSwipe` it will\n   * supersede and force passive to false.\n   *\n   */\n  var attachTouch = function attachTouch(el, props) {\n    var cleanup = function cleanup() {};\n    if (el && el.addEventListener) {\n      var baseOptions = Object.assign(Object.assign({}, defaultProps.touchEventOptions), props.touchEventOptions);\n      // attach touch event listeners and handlers\n      var tls = [[touchStart, onStart, baseOptions],\n      // preventScrollOnSwipe option supersedes touchEventOptions.passive\n      [touchMove, onMove, Object.assign(Object.assign({}, baseOptions), props.preventScrollOnSwipe ? {\n        passive: false\n      } : {})], [touchEnd, onEnd, baseOptions]];\n      tls.forEach(function (_ref3) {\n        var _ref4 = _slicedToArray(_ref3, 3),\n          e = _ref4[0],\n          h = _ref4[1],\n          o = _ref4[2];\n        return el.addEventListener(e, h, o);\n      });\n      // return properly scoped cleanup method for removing listeners, options not required\n      cleanup = function cleanup() {\n        return tls.forEach(function (_ref5) {\n          var _ref6 = _slicedToArray(_ref5, 2),\n            e = _ref6[0],\n            h = _ref6[1];\n          return el.removeEventListener(e, h);\n        });\n      };\n    }\n    return cleanup;\n  };\n  var onRef = function onRef(el) {\n    // \"inline\" ref functions are called twice on render, once with null then again with DOM element\n    // ignore null here\n    if (el === null) return;\n    set(function (state, props) {\n      // if the same DOM el as previous just return state\n      if (state.el === el) return state;\n      var addState = {};\n      // if new DOM el clean up old DOM and reset cleanUpTouch\n      if (state.el && state.el !== el && state.cleanUpTouch) {\n        state.cleanUpTouch();\n        addState.cleanUpTouch = void 0;\n      }\n      // only attach if we want to track touch\n      if (props.trackTouch && el) {\n        addState.cleanUpTouch = attachTouch(el, props);\n      }\n      // store event attached DOM el for comparison, clean up, and re-attachment\n      return Object.assign(Object.assign(Object.assign({}, state), {\n        el: el\n      }), addState);\n    });\n  };\n  // set ref callback to attach touch event listeners\n  var output = {\n    ref: onRef\n  };\n  // if track mouse attach mouse down listener\n  if (handlerProps.trackMouse) {\n    output.onMouseDown = onStart;\n  }\n  return [output, attachTouch];\n}\nfunction updateTransientState(state, props, previousProps, attachTouch) {\n  // if trackTouch is off or there is no el, then remove handlers if necessary and exit\n  if (!props.trackTouch || !state.el) {\n    if (state.cleanUpTouch) {\n      state.cleanUpTouch();\n    }\n    return Object.assign(Object.assign({}, state), {\n      cleanUpTouch: undefined\n    });\n  }\n  // trackTouch is on, so if there are no handlers attached, attach them and exit\n  if (!state.cleanUpTouch) {\n    return Object.assign(Object.assign({}, state), {\n      cleanUpTouch: attachTouch(state.el, props)\n    });\n  }\n  // trackTouch is on and handlers are already attached, so if preventScrollOnSwipe changes value,\n  // remove and reattach handlers (this is required to update the passive option when attaching\n  // the handlers)\n  if (props.preventScrollOnSwipe !== previousProps.preventScrollOnSwipe || props.touchEventOptions.passive !== previousProps.touchEventOptions.passive) {\n    state.cleanUpTouch();\n    return Object.assign(Object.assign({}, state), {\n      cleanUpTouch: attachTouch(state.el, props)\n    });\n  }\n  return state;\n}\nfunction useSwipeable(options) {\n  var trackMouse = options.trackMouse;\n  var transientState = React.useRef(Object.assign({}, initialState));\n  var transientProps = React.useRef(Object.assign({}, defaultProps));\n  // track previous rendered props\n  var previousProps = React.useRef(Object.assign({}, transientProps.current));\n  previousProps.current = Object.assign({}, transientProps.current);\n  // update current render props & defaults\n  transientProps.current = Object.assign(Object.assign({}, defaultProps), options);\n  // Force defaults for config properties\n  var defaultKey;\n  for (defaultKey in defaultProps) {\n    if (transientProps.current[defaultKey] === void 0) {\n      transientProps.current[defaultKey] = defaultProps[defaultKey];\n    }\n  }\n  var _React$useMemo = React.useMemo(function () {\n      return getHandlers(function (stateSetter) {\n        return transientState.current = stateSetter(transientState.current, transientProps.current);\n      }, {\n        trackMouse: trackMouse\n      });\n    }, [trackMouse]),\n    _React$useMemo2 = _slicedToArray(_React$useMemo, 2),\n    handlers = _React$useMemo2[0],\n    attachTouch = _React$useMemo2[1];\n  transientState.current = updateTransientState(transientState.current, transientProps.current, previousProps.current, attachTouch);\n  return handlers;\n}\nexport { DOWN, LEFT, RIGHT, UP, useSwipeable };","map":null,"metadata":{},"sourceType":"module"}