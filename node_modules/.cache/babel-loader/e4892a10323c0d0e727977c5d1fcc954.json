{"ast":null,"code":"import _toConsumableArray from \"/Users/shannonhu/Documents/Somestage/someation-website/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _slicedToArray from \"/Users/shannonhu/Documents/Somestage/someation-website/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nimport locationHook from \"./use-location.js\";\nimport matcherWithCache from \"./matcher.js\";\nimport { useContext, createContext, isValidElement, cloneElement, createElement as h, Fragment, useState, forwardRef, useIsomorphicLayoutEffect, useEvent, useInsertionEffect } from \"./react-deps.js\";\n\n/*\n * Router and router context. Router is a lightweight object that represents the current\n * routing options: how location is managed, base path etc.\n *\n * There is a default router present for most of the use cases, however it can be overridden\n * via the <Router /> component.\n */\n\nvar defaultRouter = {\n  hook: locationHook,\n  matcher: matcherWithCache(),\n  base: \"\"\n  // this option is used to override the current location during SSR\n  // ssrPath: undefined,\n};\n\nvar RouterCtx = createContext(defaultRouter);\n\n// gets the closest parent router from the context\nexport var useRouter = function useRouter() {\n  return useContext(RouterCtx);\n};\n\n/*\n * Part 1, Hooks API: useRoute and useLocation\n */\n\n// Internal version of useLocation to avoid redundant useRouter calls\nvar useLocationFromRouter = function useLocationFromRouter(router) {\n  return router.hook(router);\n};\nexport var useLocation = function useLocation() {\n  return useLocationFromRouter(useRouter());\n};\nexport var useRoute = function useRoute(pattern) {\n  var router = useRouter();\n  var _useLocationFromRoute = useLocationFromRouter(router),\n    _useLocationFromRoute2 = _slicedToArray(_useLocationFromRoute, 1),\n    path = _useLocationFromRoute2[0];\n  return router.matcher(pattern, path);\n};\n\n/*\n * Part 2, Low Carb Router API: Router, Route, Link, Switch\n */\n\nexport var Router = function Router(_ref) {\n  var hook = _ref.hook,\n    matcher = _ref.matcher,\n    ssrPath = _ref.ssrPath,\n    _ref$base = _ref.base,\n    base = _ref$base === void 0 ? \"\" : _ref$base,\n    parent = _ref.parent,\n    children = _ref.children;\n  // updates the current router with the props passed down to the component\n  var updateRouter = function updateRouter(router) {\n    var proto = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : parent || defaultRouter;\n    router.hook = hook || proto.hook;\n    router.matcher = matcher || proto.matcher;\n    router.ssrPath = ssrPath || proto.ssrPath;\n    router.ownBase = base;\n\n    // store reference to parent router\n    router.parent = parent;\n    return router;\n  };\n\n  // we use `useState` here, but it only catches the first render and never changes.\n  // https://reactjs.org/docs/hooks-faq.html#how-to-create-expensive-objects-lazily\n  var _useState = useState(function () {\n      return updateRouter({\n        // We must store base as a property accessor because effects\n        // somewhat counter-intuitively run in child components *first*!\n        // This means that by the time a parent's base is updated in the\n        // parent effect, the child effect has already run, and saw\n        // the parent's *previous* base during its own execution.\n        get base() {\n          return (value.parent || defaultRouter).base + value.ownBase;\n        }\n      });\n    }),\n    _useState2 = _slicedToArray(_useState, 1),\n    value = _useState2[0]; // create the object once...\n  useInsertionEffect(function () {\n    updateRouter(value);\n  }); // ...then update it on each render\n\n  return h(RouterCtx.Provider, {\n    value: value,\n    children: children\n  });\n};\nexport var Route = function Route(_ref2) {\n  var path = _ref2.path,\n    match = _ref2.match,\n    component = _ref2.component,\n    children = _ref2.children;\n  var useRouteMatch = useRoute(path);\n\n  // `props.match` is present - Route is controlled by the Switch\n  var _ref3 = match || useRouteMatch,\n    _ref4 = _slicedToArray(_ref3, 2),\n    matches = _ref4[0],\n    params = _ref4[1];\n  if (!matches) return null;\n\n  // React-Router style `component` prop\n  if (component) return h(component, {\n    params: params\n  });\n\n  // support render prop or plain children\n  return typeof children === \"function\" ? children(params) : children;\n};\nexport var Link = forwardRef(function (props, ref) {\n  var router = useRouter();\n  var _useLocationFromRoute3 = useLocationFromRouter(router),\n    _useLocationFromRoute4 = _slicedToArray(_useLocationFromRoute3, 2),\n    navigate = _useLocationFromRoute4[1];\n  var to = props.to,\n    _props$href = props.href,\n    href = _props$href === void 0 ? to : _props$href,\n    children = props.children,\n    onClick = props.onClick;\n  var handleClick = useEvent(function (event) {\n    // ignores the navigation when clicked using right mouse button or\n    // by holding a special modifier key: ctrl, command, win, alt, shift\n    if (event.ctrlKey || event.metaKey || event.altKey || event.shiftKey || event.button !== 0) return;\n    onClick && onClick(event);\n    if (!event.defaultPrevented) {\n      event.preventDefault();\n      navigate(to || href, props);\n    }\n  });\n\n  // wraps children in `a` if needed\n  var extraProps = {\n    // handle nested routers and absolute paths\n    href: href[0] === \"~\" ? href.slice(1) : router.base + href,\n    onClick: handleClick,\n    to: null,\n    ref: ref\n  };\n  var jsx = isValidElement(children) ? children : h(\"a\", props);\n  return cloneElement(jsx, extraProps);\n});\nvar flattenChildren = function flattenChildren(children) {\n  var _ref5;\n  return Array.isArray(children) ? (_ref5 = []).concat.apply(_ref5, _toConsumableArray(children.map(function (c) {\n    return c && c.type === Fragment ? flattenChildren(c.props.children) : flattenChildren(c);\n  }))) : [children];\n};\nexport var Switch = function Switch(_ref6) {\n  var children = _ref6.children,\n    location = _ref6.location;\n  var router = useRouter();\n  var matcher = router.matcher;\n  var _useLocationFromRoute5 = useLocationFromRouter(router),\n    _useLocationFromRoute6 = _slicedToArray(_useLocationFromRoute5, 1),\n    originalLocation = _useLocationFromRoute6[0];\n  var _iterator = _createForOfIteratorHelper(flattenChildren(children)),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var element = _step.value;\n      var match = 0;\n      if (isValidElement(element) &&\n      // we don't require an element to be of type Route,\n      // but we do require it to contain a truthy `path` prop.\n      // this allows to use different components that wrap Route\n      // inside of a switch, for example <AnimatedRoute />.\n      (match = element.props.path ? matcher(element.props.path, location || originalLocation) : [true, {}])[0]) return cloneElement(element, {\n        match: match\n      });\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n  return null;\n};\nexport var Redirect = function Redirect(props) {\n  var to = props.to,\n    _props$href2 = props.href,\n    href = _props$href2 === void 0 ? to : _props$href2;\n  var _useLocation = useLocation(),\n    _useLocation2 = _slicedToArray(_useLocation, 2),\n    navigate = _useLocation2[1];\n  var redirect = useEvent(function () {\n    return navigate(to || href, props);\n  });\n\n  // redirect is guaranteed to be stable since it is returned from useEvent\n  useIsomorphicLayoutEffect(function () {\n    redirect();\n  }, []); // eslint-disable-line react-hooks/exhaustive-deps\n\n  return null;\n};\nexport default useRoute;","map":null,"metadata":{},"sourceType":"module"}