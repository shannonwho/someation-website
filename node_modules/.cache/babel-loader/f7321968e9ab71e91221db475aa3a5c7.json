{"ast":null,"code":"import _slicedToArray from \"/Users/shannonhu/Documents/Somestage/someation-website/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\n// creates a matcher function\nexport default function makeMatcher() {\n  var makeRegexpFn = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : pathToRegexp;\n  var cache = {};\n\n  // obtains a cached regexp version of the pattern\n  var getRegexp = function getRegexp(pattern) {\n    return cache[pattern] || (cache[pattern] = makeRegexpFn(pattern));\n  };\n  return function (pattern, path) {\n    var _getRegexp = getRegexp(pattern || \"\"),\n      regexp = _getRegexp.regexp,\n      keys = _getRegexp.keys;\n    var out = regexp.exec(path);\n    if (!out) return [false, null];\n\n    // formats an object with matched params\n    var params = keys.reduce(function (params, key, i) {\n      params[key.name] = out[i + 1];\n      return params;\n    }, {});\n    return [true, params];\n  };\n}\n\n// escapes a regexp string (borrowed from path-to-regexp sources)\n// https://github.com/pillarjs/path-to-regexp/blob/v3.0.0/index.js#L202\nvar escapeRx = function escapeRx(str) {\n  return str.replace(/([.+*?=^!:${}()[\\]|/\\\\])/g, \"\\\\$1\");\n};\n\n// returns a segment representation in RegExp based on flags\n// adapted and simplified version from path-to-regexp sources\nvar rxForSegment = function rxForSegment(repeat, optional, prefix) {\n  var capture = repeat ? \"((?:[^\\\\/]+?)(?:\\\\/(?:[^\\\\/]+?))*)\" : \"([^\\\\/]+?)\";\n  if (optional && prefix) capture = \"(?:\\\\/\" + capture + \")\";\n  return capture + (optional ? \"?\" : \"\");\n};\nvar pathToRegexp = function pathToRegexp(pattern) {\n  var groupRx = /:([A-Za-z0-9_]+)([?+*]?)/g;\n  var match = null,\n    lastIndex = 0,\n    keys = [],\n    result = \"\";\n  while ((match = groupRx.exec(pattern)) !== null) {\n    var _match = match,\n      _match2 = _slicedToArray(_match, 3),\n      _ = _match2[0],\n      segment = _match2[1],\n      mod = _match2[2]; // :foo  [1]      (  )\n    // :foo? [0 - 1]  ( o)\n    // :foo+ [1 - ∞]  (r )\n    // :foo* [0 - ∞]  (ro)\n    var repeat = mod === \"+\" || mod === \"*\";\n    var optional = mod === \"?\" || mod === \"*\";\n    var prefix = optional && pattern[match.index - 1] === \"/\" ? 1 : 0;\n    var prev = pattern.substring(lastIndex, match.index - prefix);\n    keys.push({\n      name: segment\n    });\n    lastIndex = groupRx.lastIndex;\n    result += escapeRx(prev) + rxForSegment(repeat, optional, prefix);\n  }\n  result += escapeRx(pattern.substring(lastIndex));\n  return {\n    keys: keys,\n    regexp: new RegExp(\"^\" + result + \"(?:\\\\/)?$\", \"i\")\n  };\n};","map":null,"metadata":{},"sourceType":"module"}